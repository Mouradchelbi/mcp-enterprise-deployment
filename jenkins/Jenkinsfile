pipeline {
    agent any
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '685939060042'
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"
        ECR_REPOSITORY = 'mcp-server-${ENVIRONMENT}'
        EKS_CLUSTER = 'mcp-server-eks-cluster'
    }
    
    parameters {
        choice(
            name: 'ENVIRONMENT',
            choices: ['dev', 'staging', 'prod'],
            description: 'Select deployment environment'
        )
        booleanParam(
            name: 'UPDATE_JENKINS',
            defaultValue: false,
            description: 'Update Jenkins server configuration?'
        )
        booleanParam(
            name: 'DESTROY_INFRASTRUCTURE',
            defaultValue: false,
            description: 'Destroy infrastructure?'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "üîÑ Checking out code..."
            }
        }
        
        stage('Code Quality') {
            steps {
                sh '''
                    cd application
                    python3 -m pip install flake8
                    python3 -m flake8 . --max-line-length=88
                '''
            }
        }
        
        stage('Bootstrap AWS Resources') {
            when { not { expression { params.DESTROY_INFRASTRUCTURE } } }
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-moudevops-access-key'
                ]]) {
                    sh '''
                        echo "=== Installing Required Tools ==="
                        
                        # Install Terraform if not present
                        if ! command -v terraform &> /dev/null; then
                            echo "Installing Terraform..."
                            cd /tmp
                            wget -q https://releases.hashicorp.com/terraform/1.6.0/terraform_1.6.0_linux_amd64.zip
                            unzip -q terraform_1.6.0_linux_amd64.zip
                            sudo mv terraform /usr/local/bin/
                            sudo chmod +x /usr/local/bin/terraform
                            rm terraform_1.6.0_linux_amd64.zip
                        fi
                        
                        # Install kubectl if not present
                        if ! command -v kubectl &> /dev/null; then
                            echo "Installing kubectl..."
                            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
                            chmod +x kubectl
                            sudo mv kubectl /usr/local/bin/
                        fi
                        
                        # Verify installations
                        echo "=== Tool Verification ==="
                        terraform version
                        kubectl version --client
                        aws --version
                        
                        echo "=== Bootstrapping S3 Bucket and DynamoDB Table ==="
                        
                        # Check if S3 bucket exists
                        if ! aws s3 ls s3://mcp-server-terraform-state-dev 2>/dev/null; then
                            echo "Creating S3 bucket for Terraform state..."
                            aws s3 mb s3://mcp-server-terraform-state-dev --region us-east-1
                            
                            # Enable versioning
                            aws s3api put-bucket-versioning \
                                --bucket mcp-server-terraform-state-dev \
                                --versioning-configuration Status=Enabled
                                
                            # Enable encryption
                            aws s3api put-bucket-encryption \
                                --bucket mcp-server-terraform-state-dev \
                                --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
                        else
                            echo "S3 bucket already exists"
                        fi
                        
                        # Check if DynamoDB table exists
                        if ! aws dynamodb describe-table --table-name mcp-server-terraform-locks-dev --region us-east-1 2>/dev/null; then
                            echo "Creating DynamoDB table for Terraform locks..."
                            aws dynamodb create-table \
                                --table-name mcp-server-terraform-locks-dev \
                                --attribute-definitions AttributeName=LockID,AttributeType=S \
                                --key-schema AttributeName=LockID,KeyType=HASH \
                                --billing-mode PAY_PER_REQUEST \
                                --region us-east-1
                            
                            # Wait for table to be active
                            aws dynamodb wait table-exists --table-name mcp-server-terraform-locks-dev --region us-east-1
                        else
                            echo "DynamoDB table already exists"
                        fi
                        
                        echo "Bootstrap completed successfully"
                    '''
                }
            }
        }EncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
                        else
                            echo "S3 bucket already exists"
                        fi
                        
                        # Check if DynamoDB table exists
                        if ! aws dynamodb describe-table --table-name mcp-server-terraform-locks-dev --region us-east-1 2>/dev/null; then
                            echo "Creating DynamoDB table for Terraform locks..."
                            aws dynamodb create-table \
                                --table-name mcp-server-terraform-locks-dev \
                                --attribute-definitions AttributeName=LockID,AttributeType=S \
                                --key-schema AttributeName=LockID,KeyType=HASH \
                                --billing-mode PAY_PER_REQUEST \
                                --region us-east-1
                            
                            # Wait for table to be active
                            aws dynamodb wait table-exists --table-name mcp-server-terraform-locks-dev --region us-east-1
                        else
                            echo "DynamoDB table already exists"
                        fi
                        
                        echo "Bootstrap completed successfully"
                    '''
                }
            }
        }
        
        stage('Terraform: Plan') {
            when { not { expression { params.DESTROY_INFRASTRUCTURE } } }
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-moudevops-access-key'
                ]]) {
                    sh '''
                        cd terraform/environments/${ENVIRONMENT}
                        terraform version
                        terraform init
                        terraform plan -out=tfplan -var="deployment_target=eks"
                    '''
                }
            }
        }
        
        stage('Terraform: Apply') {
            when { not { expression { params.DESTROY_INFRASTRUCTURE } } }
            tools {
                terraform 'terraform'
            }
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-moudevops-access-key'
                ]]) {
                    sh '''
                        cd terraform/environments/${ENVIRONMENT}
                        terraform apply -auto-approve tfplan
                        
                        # Get outputs and store them
                        echo "Getting Terraform outputs..."
                        terraform output -json > terraform-outputs.json
                        
                        # Extract outputs safely (avoiding terminal color codes)
                        RDS_ENDPOINT=$(terraform output -raw rds_endpoint 2>/dev/null || echo "")
                        REDIS_ENDPOINT=$(terraform output -raw redis_endpoint 2>/dev/null || echo "")
                        
                        echo "RDS_ENDPOINT=${RDS_ENDPOINT}" > ../../../terraform-vars.env
                        echo "REDIS_ENDPOINT=${REDIS_ENDPOINT}" >> ../../../terraform-vars.env
                        
                        echo "Terraform outputs saved to terraform-vars.env"
                    '''
                }
            }
        }
        
        stage('Ansible: Update Jenkins') {
            when { expression { params.UPDATE_JENKINS } }
            steps {
                sh '''
                    cd ansible
                    ansible-playbook -i inventories/${ENVIRONMENT}/hosts playbooks/deploy-mcp-server.yml \
                        -e "environment=${ENVIRONMENT}" \
                        -e "task=jenkins_config"
                '''
            }
        }
        
        stage('Build and Push Docker Image') {
            when { not { expression { params.DESTROY_INFRASTRUCTURE } } }
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-moudevops-access-key'
                ]]) {
                    sh '''
                        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        cd application
                        docker build -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${GIT_COMMIT} .
                        docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${GIT_COMMIT}
                    '''
                }
            }
        }
        
        stage('Deploy to EKS') {
            when { not { expression { params.DESTROY_INFRASTRUCTURE } } }
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-moudevops-access-key'
                ]]) {
                    sh '''
                        # Update kubeconfig
                        aws eks update-kubeconfig --region ${AWS_DEFAULT_REGION} --name ${EKS_CLUSTER}-${ENVIRONMENT}
                        
                        # Load terraform outputs
                        source terraform-vars.env
                        
                        cd ansible
                        ansible-playbook -i inventories/${ENVIRONMENT}/hosts playbooks/deploy-mcp-server.yml \
                            -e "environment=${ENVIRONMENT}" \
                            -e "task=prepare_eks" \
                            -e "ecr_registry=${ECR_REGISTRY}" \
                            -e "ecr_repository=${ECR_REPOSITORY}" \
                            -e "git_commit=${GIT_COMMIT}" \
                            -e "aws_region=${AWS_DEFAULT_REGION}" \
                            -e "rds_endpoint=${RDS_ENDPOINT}" \
                            -e "redis_endpoint=${REDIS_ENDPOINT}"
                    '''
                }
            }
        }
        
        stage('Terraform: Destroy') {
            when { expression { params.DESTROY_INFRASTRUCTURE } }
            tools {
                terraform 'terraform'
            }
            steps {
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'aws-moudevops-access-key'
                ]]) {
                    input message: "Destroy ${ENVIRONMENT} infrastructure?", ok: 'Yes'
                    sh '''
                        cd terraform/environments/${ENVIRONMENT}
                        terraform destroy -auto-approve
                    '''
                }
            }
        }
    }
    
    post {
        always {
            // Clean up terraform vars file
            sh 'rm -f terraform-vars.env'
        }
        success {
            echo "‚úÖ Pipeline completed successfully"
        }
        failure {
            echo "‚ùå Pipeline failed"
        }
    }
}